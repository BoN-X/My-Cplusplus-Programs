# 知乎大神面经

## C++内存管理考点：

### C++的构造函数，拷贝构造函数和析构函数

* 回答模板：**构造函数**用于初始化对象，支持重载；**拷贝构造函数**用于通过已有对象创建新对象，特别在值传递、返回时被调用；**析构函数**在对象销毁时自动调用，释放资源。如果类涉及资源管理，我会遵循 Rule of Three，显式实现这三个函数来保证深拷贝与资源安全。同时，如果有继承关系，析构函数需要声明为 virtual，确保多态下的析构顺序正确。

拷贝构造函数默认状态下为"浅拷贝"，如果类涉及资源(堆内存，文件句柄)，需定义为"深拷贝"。

* **Rule of Three**
  如果一个类需要手写拷贝构造函数、赋值运算符或析构函数的任意一个，通常写全三个

  ```
  class MyClass {
  public:
  	Myclass(const MyClass&);                //拷贝构造
  	MyClass& operator=(const MyClass&);     //拷贝赋值
  	~MyClass();                             //析构
  };
  ```

### 深拷贝(Deep Copy)和浅拷贝(Shallow Copy)

* 回答模板：**浅拷贝**只是复制指针，多个对象共享资源，容易出现问题如双重释放；**深拷贝**会分配新内存并复制数据，确保每个对象的资源独立。

  ```
  class MyClass {
  public:
       int* data;

       MyClass(int val) {
  	data = new int(val);
       }

       ~MyClass() {
  	delete data;
       }

       //深拷贝构造函数
       MyClass(conts MyClass& other) {
  	data = new int(*other.data);
       }

       //深拷贝赋值运算符
       MyClass& operator=(const MyClass& other) {
  	if(this == &other) return *this;    //自我赋值检查
  	delete data;			    //清除原数据
  	data = new int(*other.data);	    //分配新内存
  	return *this;
       }
  };
  ```

### 构造函数和析构函数哪个能写成虚函数，为什么

* 回答模板：在C++中，**析构函数可以是虚函数，而构造函数不能是虚函数**。
  原因：构造函数在对象构造阶段调用，而此时派生类对象尚未完全构造，虚函数机制尚未建立，因此构造函数不能是virtual。相反，**析构函数在销毁对象时会通过虚表来决定调用顺序**。如果类是作为基类使用并且含有虚函数，**析构函数必须是virtual**，否则**通过基类指针删除派生对象**时，派生类的析构函数不会被调用，可能导致资源泄露或未定义行为。

  ```
  calss Base {
  public:
      virtual ~Base();     //必须
  };

  class Derived : public Base {
  public:
      ~Derived();          //自动virtual，确保正确销毁
  };

  Base* p = new Derived();
  delete p;            //正确调用Derived 和 Base析构函数
  ```

  关于为什么不用虚析构函数派生类的析构函数就不会被调用？

  C++通过**虚函数表(vtable)**实现多态。
* 如果析构函数是virtual，那么delete时会通过虚表查找最合适的析构函数，从派生类开始销毁
* 如果不是virtual，delete只是静态绑定调用基类的析构函数，派生类部分根本不会管

### 虚函数和虚表的原理是什么(重点)

* 回答模板:在C++中，**虚函数**是通过**虚函数表(vtable)**和**虚指针(vptr)**机制实现的。
  每个含有虚函数的类，编译器会为其生成一张虚函数表(vtable)，表中存储的是该类的虚函数地址。每个对象内部会有一个隐藏的虚指针(vptr)，指向其所属类的虚函数表。
  当我们通过**基类指针或引用**调用虚函数时，实际调用的是对象的vptr指向的虚函数表中的函数地址，从而实现**运行时多态(动态绑定)**。

扩展：

* 每个类只有一张vtable，共享给所有对象
* 每个对象只有一个vptr指向它对应类的vtable
* vptr通常在构造函数中自动由编译器初始化
* 如果类中有纯虚函数，则该类为抽象类，不能被实例化

#### 细节补充

##### C++对象模型

对 C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的，简称为V-Table。

在这个表中，存放的是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。

这样，这个类的实例内存中都有一个虚函数表的指针，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

```C++
class Point {
public:
	Point(float xval); 
	virtual ~Point();
	float x() const；
                   static int PointCount();
protected:
	virtual ostream& print( ostream &os ) const;
	float _x;
	static int _point_count;
};
```

上述类的对象模型

![vtable](./image/vtable.png)

##### 动态多态底层原理

在底层，当一个类声明一个虚函数时，编译器会为该类创建一个虚函数表（Virtual Table）。这个表存储着该类的虚函数指针，这些指针指向实际实现该虚函数的代码地址。

**在派生类中，如果重写了基类的虚函数，那么该函数在派生类的虚函数表中的地址会被更新为指向派生类中实际实现该函数的代码地址。**

C++的动态多态必须满足两个条件：

* **必须通过基类的指针或者引用调用虚函数**
* **被调用的函数是虚函数，且必须完成对基类虚函数的重写**

其中第一条很重要，当我们使用派生类的指针去访问/调用虚函数时，实际上并未发生动态多态，因为编译时就能确定对象类型为派生类型，然后直接生成调用派生类虚函数的代码即可，这种叫做 **静态绑定** 。

通过基类的指针或引用调用虚函数才能构成多态，因为这种情况下运行时才能确定对象的实际类型，这种称为**动态绑定。**

### C++数组，链表，二叉树的内存排列是怎么样的

回答模板：数组在内存中是连续分配的，因此支持O(1)的随机访问，缓存友好。链表和二叉树是非连续分配的结构，每个节点通过new分配，彼此通过指针链接；链表适合频繁插入删除，二叉树用于结构化存储，如搜索、排序，但他们内存局部性较差，性能不如数组。

### 结构体占多大内存，如何计算(知识点：内存对齐)

回答模板：C++中结构体内存大小由其成员类型、排列顺序和对其方式决定。默认情况下，编译器会插入padding来保证每个成员的对齐需求；结构体总大小通常是最大对齐值的整数倍。可以用sizeof来查看实际大小，也可以用#pragma pack或 alignas控制对齐。

补充：

```
struct MyStruct {
    char a;   // 1 byte
    int b;    // 4 bytes, 需要对齐
    short c;  // 2 bytes
};
// 1 + 3 + 4 + 2 + 2 = 12
```

```
struct Optimized {
    int b;    // 4 bytes
    short c;  // 2 bytes
    char a;   // 1 byte
};
// 4 + 2 + 1 + 1 = 8
```

从上面两个例子可以看出最好的排序是**从大到小**

```
struct Inner {
    char x;  // 1 byte
    int y;   // 4 bytes → 需要 3 字节 padding
};

struct Outer {
    Inner a;  // 8 bytes
    double b; // 8 bytes
};
// 8 + 8 = 16
```

### 类占用多大空间如何计算，空类的空间是多少，为什么

回答模板：C++中类的大小由其**非静态成员变量**、**内存对齐规则**、**虚函数指针**、**继承结构**决定。

空类占1个字节，为了满足规定"**每个对象具有唯一地址**""可以对对象取地址并合法使用"。

静态成员不计入对象大小。若类中包含虚函数，则每个对象会额外包含一个vptr指针，一般4字节(32位)或8字节(64位)。

在 C++ 中，“ **类** ”本身并不占用运行时空间； **是类的“对象”才占用内存空间** 。所以，当我们讨论“类的大小”时，准确地说是： **类的对象实例占用多少空间（`sizeof(ClassName)`）** 。

### 内存泄露出现的时机和原因，如何避免

回答模板：内存泄漏是指程序在堆上分配了内存但是没有释放，且失去了对该内存的引用，导致内存无法再利用。常见的原因包括忘记释放、异常中断、提前return、指针覆盖、循环引用等。

为了避免内存泄漏，可以采用智能指针(如unique_ptr, shared_ptr)、RAII原则、异常安全机制，并借助工具如Valgrind或AddressSanitizer进行检测。

RAII(Resource Acquisition Is Initialization) 资源获取即初始化

### 指针的工作原理

回答模板：指针是存储变量地址的变量，是 C++ 中访问和操作内存的基本手段。每个指针占用一定大小（通常是 4 或 8 字节），它保存另一个变量在内存中的地址。通过解引用操作符 `*` 可以访问或修改指针指向的值。指针的类型决定了解引用时解释内存内容的方式。合理使用指针能带来高性能，但错误使用会导致崩溃或内存泄漏，因此需要配对释放或使用智能指针确保安全。

有关空指针(nullptr或NULL)：空指针本质上是一个值为 0 的地址，表示“当前不指向任何有效内存”。它是合法的指针值，可以被比较、赋值，但不能被解引用。和未初始化的野指针不同，空指针具有确定的值（0）。在 C++ 中推荐使用类型安全的 `nullptr` 表示空指针。

### 函数的参数传递

回答模板：C++中函数的参数的三种传递机制包括按值传递(pass by value)、指针传递(pass by pointer)和引用传递(pass by reference)。**按值传递**会复制一份实参，修改不影响原变量；**地址传递**将指针传入，可以修改原值，但需要手动取地址和判断空指针；**引用传递**则是给形参一个别名，语法简洁、安全高效，现代 C++ 推荐优先使用引用传递。

小对象用值传递；大对象或类对象用const T&。     STL习惯使用const T&做只读传参。

值传递和引用传递在被调函数的形参都会作为局部变量在堆栈中开辟内存空间，但是值传递存的是实参的副本，引用传递存的是实参变量的地址。在引用传递过程中，被调函数对形参的任何操作都被处理成间接寻址。

### new和delete使用解释一下，和malloc和free的区别

回答模板：在 C++ 中，`new`/`delete` 是用于动态内存管理的关键字，它们不仅分配和释放内存，还会自动调用构造和析构函数，是类型安全的。相比之下，`malloc`/`free` 是 C 风格的函数，只进行字节级的内存管理，不支持对象的构造/析构。C++ 中推荐使用 `new`/`delete`，并在现代开发中建议使用智能指针来自动管理内存，避免泄漏。

### C++内存区域划如何分说一下

* 栈区(**Stack**)：由编译器自动管理(自动分配，自动释放)，存放**局部变量**、**函数参数**、**返回地址**、**栈帧信息**。内存空间小但访问速度非常快。超出作用域自动释放。
* 堆区(**Heap**)：由程序员显示管理(new/delete或malloc/free)，存储动态分配的内存块，内存大但管理负责，可能产生内存泄漏。
* 全局/静态区(**Data Segment**)：分为**已初始化区(.data)**和**未初始化区(.bss)**。.data区主要存储已初始化的全局变量和静态变量, .bss区主要存放未初始化的全局变量或静态变量
* 常量区(只读数据区**.rodata**)：存储**常量**、**字符串字面量**、**const修饰的全局变量**，通常只读。
* 代码区(**Text Segment**)：存储程序的**可执行机器指令**，通常只读，多程序共享

```
高地址
│
│  栈区（局部变量、函数调用）
│  ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
│  堆区（new 分配）
│  ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
│  全局/静态区（全局变量、静态变量）
│  只读常量区（字符串、const 全局变量）
│  代码区（函数体、指令）
│
低地址
```

## C++ 11新特性

### C++11 auto类型推导

**语法**：auto 变量  = 初始值；   注：auto仅仅是一个占位符，在编译期间它会被真正的类型所替代。

**auto和const结合时**：

```
int  x = 0;
const  auto n = x;  //n 为 const int ，auto 被推导为 int
auto f = n;      //f 为 const int，auto 被推导为 int（const 属性被抛弃）
const auto &r1 = x;  //r1 为 const int& 类型，auto 被推导为 int
auto &r2 = r1;  //r1 为 const int& 类型，auto 被推导为 const int 类型
```

* 当类型不为引用时，auto的推导结果将不保留表达式的const属性；
* 当类型为引用时，auto的推导结果将保留表达式的const属性；

**auto的限制：**

1. 使用auto的时候必须对变量进行初始化
2. auto不能在函数的参数中使用
3. auto不能作用于类的非静态成员变量(也就是没有static修饰的成员变量)
4. auto关键字不能定义数组
5. auto不能作用于模板参数

**auto的应用：**

* 使用auto定义迭代器

```
#include <vector>
using namespace std;
int main(){
    vector< vector<int> > v;
    //vector< vector<int> >::iterator i = v.begin();
    auto i = v.begin();     //使用auto代替具体的类型
    return 0;
}
```

* auto用于泛型编程

```
#include <iostream>
using namespace std;
class A {
public:
    static int get(void) {
	return 100;
    }
};
class B {
    static const char* get(void) {
	return "http://c.biancheng.net/cplus/";
    }
};
template <typename T>
void func(void) {
    auto val = T::get();
    cout << val << endl;
}

int main(void) {
    func<A>();
    func<B>();
    return 0;
}

//如果使用auto,需要额外增加一个模板参数，并在调用时手动给模板参数赋值
template <typename T1, typename T2>
void func(void) {
    T2 val = T1::get();
    cout << val << endl;
}
int main(void) {
    //调用时也要手动给模板参数赋值
    func<A, int>();
    func<B, const char*>();
    return 0;
}
```

### C++11 decltype类型推导

decltype是C++11新增的关键字，和auto功能一样，都是在编译时期进行自动类型推导。decltype是"declare type"的缩写，译为"声明类型"。

**语法**：decltype(exp) varname [= value];     //varname变量名，value变量的值，exp表示一个表达式。

decltype根据exp表达式推导出变量的类型，跟=右边的value无关。auto要求变量必须初始化，decltype并不要求，但是exp表达式的结果必须是有类型的。

例子：

```
int a = 0;
decltype(a) b = 1;  //b 被推导成了 int
decltype(10.8) x = 5.5;  //x 被推导成了 double
decltype(x + 100) y;  //y 被推导成了 double
```

**decltype推导规则：**

* 如果 exp 是一个不被括号 `( )`包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。
* 如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。
* 如果 exp 是一个左值，或者被括号 `( )`包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&。

  注：exp中调用函数时需要带上括号和参数，但这仅仅是形式，并不会真的去执行函数代码

  decltype的实际应用：推导非静态成员的类型
* ```
  #include <vector>
  using namespace std;
  template <typename T>
  class Base {
  public:
      void func(T& container) {
          m_it = container.begin();
      }
  private:
      typename T::iterator m_it;  //注意这里
  };
  int main()
  {
      const vector<int> v;
      Base<const vector<int>> obj;
      obj.func(v);
      return 0;
  }
  ```

  单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，`T::iterator`并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。

  ```
  template <typename T>
  class Base {
  public:
      void func(T& container) {
          m_it = container.begin();
      }
  private:
      decltype(T().begin()) m_it;  //注意这里
  };
  ```

### C++11 使用using定义别名(替代typedef)        注：using还有引入命名空间成员的作用

C++中可以通过typedef重定义一个类型，被定义的类型并不是一个新的类型，仅仅是原有类型取了一个新的名字。并且存在一些限制，比如，无法重定义一个模板。

比如以下场景：

typedef std::map<std::string, int> map_int_t;

typedef std::map<std::string, std::string> map_str_t;

需要一个固定以std::string为key的map，它可以映射到int或另一个std::string，仅用typedef很难办到

```
C++98/03
template <typename Val>
struct str_map
{
    typedef std::map<std::string, Val> type;
}
str_map<int>::type map1;
```

```
C++11
template <typename Val>
using str_map_t = std::map<std::string, Val>;
str_map_t<int> map1;
```

这里用新的using别名语法定义了std::map的模板别名str_map_t。

在重定义普通类型上，两种使用方法的效果是等价的，唯一不同的是定义语法。

typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C/C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时： **typedef void (*func_t)(int, int);**

与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型： **using func_t = void (*)(int, int);**

### C++11 tuple元组详解

C++11标准新引入了一种类模板，命名为tuple (元组)。**最大特点：实例化的对象可以存储任意数量、任意类型的数据。**

#### 类的构造函数

```
1）默认构造函数
constexpr tuple();
2) 拷贝构造函数
tuple (const tuple& tpl);
3) 移动构造函数
tuple (tuple&& tuple);
4) 隐式类型转换构造函数
template <class... UTypes>
	tuple (const tuple<UTypes...>& tpl);   //左值方式
template <class... UTypes>
	tuple (tuple<UTypes...>&& tpl);        //右值方式
5) 支持初始化列表的构造函数
explicit tuple (const Types&... elems);        //左值方式
template <class... UTypes>
	explicit tuple (UTypes&&... elems);    //右值方式
6) 将pair对象转换为tuple对象
template <class U1, class U2>
	tuple (const pair<U1, U2>& pr);        //左值方式
template <class U1, class U2>
	tuple (pair<U1, U2>&& pr);             //右值方式

例子：
#include <iostream>
#include <tuple>
using std::tuple;
int main() {
    std::tuple<int, char> first;                           //1) first{}
    std::tuple<int, char> second(first);                   //2) second{}
    std::tuple<int, char> third(std::make_tuple(20, 'b')); //3) third{20, 'b'}
    std::tuple<long, char> fourth(third);                  //4) 左值, fourth{20, 'b}
    std::tuple<int, char> fifth(10, 'a');                  //5) 右值，fifth{10, 'a'}
    std::tuple<int, char> sixth(std::make_pair(30, 'c'));  //6) 右值，sixth{30, 'c'}
    return 0;
}
```

#### make_tuple()函数

上面程序中，我们已经用到了 make_tuple() 函数，它以模板的形式定义在 头文件中，功能是创建一个 tuple 右值对象（或者临时对象）。

对于 make_tuple() 函数创建了 tuple 对象，我们可以上面程序中那样作为移动构造函数的参数，也可以这样用：

```
auto first = stdd::make_tuple (10, 'a');   //tuple<int, char>
const int a = 0; int b[3];
auto second = std::make_tuple (a, b);      //tuple<int, int*>
```

#### tuple常用函数

| 函数或类模板                          | 描述                                                                                                                                                                    |
| ------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| tup1.swap(tup2)<br />swap(tup1, tup2) | tup1和tup2表示类型相同的两个tuple对象，tuple模板类中定义有一个swap()成员函数，头文件还提供<br />一个同名的swap()全局函数。swap()函数的功能是交换两个tuple对象存储的内容 |
| get(tup)                              | tup表示某个tuple对象，num是一个整数，get()是头文件提供的全局函数，功能是返回tup对象中第<br />num+1个元素                                                                |
| tuple_size `<type>`::value          | tuple_size是定义在头文件的类模板，它只有一个成员变量value,功能是获取某个tuple对象中元素的个数，<br />type为该tuple对象的类型                                            |
| tuple_element<I,<br /> type>::type    | tuple_element 是定义在 头文件的类模板，它只有一个成员变量 type，功能是获取某个 tuple 对象<br />第 I+1 个元素的类型。                                                    |
| forward_as_tuple<br /><args…>        | args… 表示 tuple 对象存储的多个元素，该函数的功能是创建一个 tuple 对象，内部存储的 args…<br />元素都是右值引用形式的。                                                |
| tie(args…) = tup                     | tup 表示某个 tuple 对象，tie() 是 头文件提供的，功能是将 tup 内存储的元素逐一赋值给 args…<br /> 指定的左值变量。                                                       |
| tuple_cat(args…)                     | args… 表示多个 tuple 对象，该函数是 头文件提供的，功能是创建一个 tuple 对象，此对象包含 args…<br />指定的所有 tuple 对象内的元素。                                    |

tuple 模板类对赋值运算符 = 进行了重载，使得同类型的 tuple 对象可以直接赋值。此外，tuple 模板类还重载了 ==、!=、<、>、>=、<= 这几个比较运算符，同类型的 tuple 对象可以相互比较（逐个比较各个元素）。

### C++ lambda匿名函数用法详解

#### lambda匿名函数的定义

```
[外部变量访问方式说明符](参数) mutable noexcept/throw()-> 返回值类型
{
函数体;
};

[capture](parameters) mtuable -> return_type {
//code
};
```

各部分含义：

* **[外部变量访问方式说明符]**
  []方括号用于向编译器表明当前是一个lambda表达式，其不能被省略。在方括号内部，可以注明当前lambda函数的函数体中可以使用哪些"外部变量"。

| 外部变量格式     | 功能                                                                               |
| ---------------- | ---------------------------------------------------------------------------------- |
| []               | 空方括号表示当前 lambda 匿名函数中不导入任何外部变量。                             |
| [=]              | 只有一个=等号，表示以值传递的方式导入所有外部变量。                                |
| [&]              | 只有一个&符号，表示以引用传递的方式导入所有外部变量。                              |
| [val1, val2,...] | 表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序； |
| [&val1,&val2,…] | 表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；    |
| [val,&val2,…]   | 以上 2 种方式还可以混合使用，变量之间没有前后次序。                                |
| [=,&val1,…]     | 表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。             |
| [this]           | 表示以值传递的方式导入当前的 this 指针。                                           |

注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。

* **(参数)**

和普通参数的定义一样，lambda匿名函数也可以接受外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同()一起省略；

* **mutable**

  此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。

  对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；
* **noexcept/throw()**

  可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。
* **-> 返回值类型**

  指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略 `-> 返回值类型`。
* **函数体**

  和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。

#### lambda匿名函数的典型应用

**STL算法**

```
std::vector<int> numbers{3,1,4,1,5,9,2,6};
std::sort(numbers.begin(), number.end(),
     [](int a, int b) {return a > b;});        //降序排列

int count = std::count_if(number.begin(), numbers.end(),
    [threshold=5](int x) {return x > threshold; });  //统计大于5的元素
```

**多线程编程**

```
#include <thread>
#include <vector>

void parallel_process() {
    std::vector<std::thread> workers;
    for(int i = 0; i < 5; i++) {
        workers.emplace_back([i] {
  	    std::cout << "Thread " << i << "working\n";
        });
    }
    for(auto& t : workers) {
        t.join();
    }
}
```

**延迟执行**

```
auto create_logger = [](const std::string& prefix) {
    return [=](const auto& message) {         //值捕获prefix
        std::cout << "[" << prefix << "]" << message << "\n";  
    };
};

auto error_log = create_logger("ERROR");
error_log("File not found");              // [ERROR] File not found
```

#### C++标准演进

| 版本   | 新特性                 | 示例                            |
| ------ | ---------------------- | ------------------------------- |
| C++ 11 | 基础Lambda语法         | [](int x) { return x;  }      |
| C++ 14 | 泛型参数，初始化捕获   | [x = 5] ( ) { ... }            |
| C++ 17 | constexpr Lambda       | constexpr auto l = []{}         |
| C++20  | 模板参数列表，概念约束 | [ ]`<typename T> (T x) {...}` |

### C++非受限联合体union

在 C/[C++](http://c.biancheng.net/cplus/) 中，联合体（Union）是一种构造数据类型。在一个联合体内，我们可以定义多个不同类型的成员，这些成员将会共享同一块内存空间。

C++11 标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。

```
class Student{
public:
    Student(bool g, int a): gender(g), age(a) {}
private:
    bool gender;
    int age;
};
union T{
    Student s;  // 含有非POD类型的成员，gcc-5.1.0  版本报错
    char name[10];
};
int main(){
    return 0;
}
```

1. c++11 允许非POD类型、
   C++98不允许联合体的成员是POD类型，但是再C++11中取消了这种机制。
   **POD是C++中一个比较重要的概念，在这里我们做一个简单的介绍。POD是英文Plain Old Data的缩写，用来描述一个类型的属性。**
   POD类型的主要特征(包括class、union、struct等):

   1. 没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数。
   2. 不能包含虚函数和虚基类。
   3. 非静态成员必须被声明为public。
   4. 类中的第一个非静态成员的类型与其基类不同。
   5. 在类或者结构体继承时，满足以下两种情况之一：
      ·派生类中有非静态成员，且只有一个仅包含静态成员的基类；
      ·基类有非静态成员，而派生类没有非静态成员。
   6. 所有非静态数据成员均和其基类也符合上述规则，也就是说POD类型不能包含非POD类型的数据。
   7. 此外，所有兼容C语言的数据类型都是POD类型(struct、union等不能违背上述规则)。
2. c++11允许联合体有静态成员
   C++11删除了联合体不允许拥有静态成员的限制。例如：

   ```
   union U {
       static int func() {
           int n = 3;
   	return n;
       }
   };
   ```

    但是静态成员变量只能在联合体内定义，却不能在联合体外使用，这使得该规则很没用。

### C++11 for循环

在C++11 标准中，为for循环添加了一种全新的语法格式：

```
for (declaration : expression) {
//循环体
}
```

·declaration: 表示此处要定义一个变量，该变量的类型为要遍历序列中存储元素的类型。需要注意的时，C++11标准中，declaration参  数处定义的变量类型可以用auto关键字表示，该关键字可以使编译器自行推导该变量的数据类型。

·expression: 表示要便利的序列，常见的可以为事先定义好的普通数组或容器，还可以是用{}大括号初始化的序列。

另外值得一提的是，在使用新语法格式的 for 循环遍历某个序列时，如果需要遍历的同时修改序列中元素的值，实现方案是在 declaration 参数处定义引用形式的变量。举个例子：

```
#include <iostream>
#include <vector>
using namespace std;
int main() {
    char arc[] = "abcde";
    vector<char> myvector(arc, arc + 5);
    //for循环遍历并修改容器中各个字符的值
    for (auto &ch : myvector) {
         ch++;
    }
    //for循环遍历输出容器中各个字符
    for (auto ch : myvector) {
         cout << ch;
    }
    return 0;
}
```

如果需要在遍历序列的过程中修改器内部元素的值，就必须定义引用形式的变量；反之，建议定义 `const &`（常引用）形式的变量（避免了底层复制变量的过程，效率更高），也可以定义普通变量。
